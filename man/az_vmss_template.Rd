% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/az_vmss_template.R
\docType{class}
\name{az_vmss_template}
\alias{az_vmss_template}
\title{Virtual machine scaleset (cluster) template class}
\format{An R6 object of class \code{az_vmss_template}, inheriting from \code{AzureRMR::az_template}.}
\usage{
az_vmss_template
}
\description{
Class representing a virtual machine scaleset deployment template. This class keeps track of all resources that are created as part of deploying a scaleset, and exposes methods for managing them.
}
\details{
A virtual machine scaleset in Azure is actually a collection of resources, including any and all of the following.
\itemize{
\item Network security group (Azure resource type \code{Microsoft.Network/networkSecurityGroups})
\item Virtual network (Azure resource type \code{Microsoft.Network/virtualNetworks})
\item Load balancer (Azure resource type \code{Microsoft.Network/loadBalancers})
\item Public IP address (Azure resource type \code{Microsoft.Network/publicIPAddresses})
\item Autoscaler (Azure resource type \code{Microsoft.Insights/autoscaleSettings})
\item The scaleset itself (Azure resource type \code{Microsoft.Compute/virtualMachineScaleSets})
}

By wrapping the deployment template used to create these resources, the \code{az_vmss_template} class allows managing them all as a single entity.
}
\section{Fields}{

The following fields are exposed, in addition to those provided by the \link[AzureRMR:az_template]{AzureRMR::az_template} class.
\itemize{
\item \code{dns_name}: The DNS name for the scaleset (technically, the name for its load balancer). Will be NULL if the scaleset is not publicly visible, or doesn't have a load balancer attached.
\item \code{identity}: The managed identity details for the scaleset. Will be NULL if the scaleset doesn't have an identity assigned.
}
}

\section{Methods}{

The following methods are available, in addition to those provided by the \link[AzureRMR:az_template]{AzureRMR::az_template} class.
\itemize{
\item \code{sync_vmss_status}: Check the status of the scaleset.
\item \code{list_instances()}: Return a list of \link{az_vm_resource} objects, one for each VM instance in the scaleset. Note that if the scaleset has an autoscaler attached, the number of instances will vary depending on the load.
\item \code{get_instance(id)}: Return a specific VM instance in the scaleset.
\item \code{start(id=NULL, wait=FALSE)}: Start the scaleset. In this and the other methods listed here, \code{id} can be an optional character vector of instance IDs; if supplied, only carry out the operation for those instances.
\item \code{restart(id=NULL, wait=FALSE)}: Restart the scaleset.
\item \code{stop(deallocate=TRUE, id=NULL, wait=FALSE)}: Stop the scaleset.
\item \code{get_public_ip_address()}: Get the public IP address of the scaleset (technically, of the load balancer). If the scaleset doesn't have a load balancer attached, returns NA.
\item \code{get_vm_public_ip_addresses(id=NULL, nic=1, config=1)}: Get the public IP addresses for the instances in the scaleset. Returns NA for the instances that are stopped or not publicly accessible.
\item \code{get_vm_private_ip_addresses(id=NULL, nic=1, config=1)}: Get the private IP addresses for the instances in the scaleset.
\item \code{get_public_ip_resource()}: Get the Azure resource for the load balancer's public IP address.
\item \code{get_vnet(nic=1, config=1)}: Get the scaleset's virtual network resource.
\item \code{get_nsg(nic=1, config=1)}: Get the scaleset's network security group resource.
\item \code{get_load_balancer()}: Get the scaleset's load balancer resource.
\item \code{get_autoscaler()}: Get the scaleset's autoscaler resource.
\item \code{run_deployed_command(command, parameters=NULL, script=NULL, id=NULL)}: Run a PowerShell command on the instances in the scaleset.
\item \code{run_script(script, parameters=NULL, id=NULL)}: Run a script on the VM. For a Linux VM, this will be a shell script; for a Windows VM, a PowerShell script. Pass the script as a character vector.
\item \code{reimage(id=NULL, datadisks=FALSE)}: Reimage the instances in the scaleset. If \code{datadisks} is TRUE, reimage any attached data disks as well.
\item \code{redeploy(id=NULL)}: Redeploy the instances in the scaleset.
\item \code{mapped_vm_operation(..., id=NULL)}: Carry out an arbitrary operation on the instances in the scaleset. See the \code{do_operation} method of the \link[AzureRMR:az_resource]{AzureRMR::az_resource} class for more details.
\item \code{add_extension(publisher, type, version, settings=list(), protected_settings=list(), key_vault_settings=list())}: Add an extension to the scaleset.
\item \code{do_vmss_operation(...)} Carry out an arbitrary operation on the scaleset resource (as opposed to the instances in the scaleset).
}

Many of these methods are actually provided by the \link{az_vmss_resource} class, and propagated to the template as active bindings.
}

\section{Instance operations}{

AzureVM has the ability to parallelise scaleset instance operations using a background process pool provided by AzureRMR. This can lead to significant speedups when working with scalesets with high instance counts. The pool is created automatically the first time that it is required, and remains persistent for the session. For more information, see \link[AzureRMR:init_pool]{AzureRMR::init_pool}.

The \code{id} argument lets you specify a subset of instances on which to carry out an operation. This can be a character vector of instance IDs; a list of instance objects such as returned by \code{list_instances}; or a single instance object. The default (NULL) is to carry out the operation on all instances.
}

\examples{
\dontrun{

sub <- AzureRMR::get_azure_login()$
    get_subscription("subscription_id")

vmss <- sub$get_vm_scaleset("myscaleset")

vmss$identity

vmss$get_public_ip_address()  # NA if the scaleset doesn't have a load balancer

vmss$start()
vmss$get_vm_private_ip_addresses()
vmss$get_vm_public_ip_addresses()  # NA if scaleset nodes are not publicly visible

instances <- vmss$list_instances()
first <- instances[1]
vmss$run_script("echo hello world! > /tmp/hello.txt", id=first)
vmss$stop(id=first)
vmss$reimage(id=first)

vmss$sync_vmss_status()

}
}
\seealso{
\link[AzureRMR:az_template]{AzureRMR::az_template}, \link{create_vm_scaleset}, \link{get_vm_scaleset}, \link{delete_vm_scaleset}, \link[AzureRMR:init_pool]{AzureRMR::init_pool}

\href{https://docs.microsoft.com/en-us/rest/api/compute/virtualmachinescalesets}{VM scaleset API reference}
}
\keyword{datasets}
